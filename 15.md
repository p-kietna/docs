You're absolutely right to question this — and here's the core issue:

---

### ❌ Why `queue.push(failed)` Doesn’t Work in `reduce`

When you use:

```ts
await queue.reduce(async (prevPromise, chunk) => {
  await prevPromise;
  // ...
  queue.push(failed);
}, Promise.resolve());
```

You're modifying `queue` **while iterating over it**, but `reduce` only processes the **original array length**. Any new items pushed into `queue` are **not included** in the current `reduce` execution.

---

### ✅ What You Need Instead: Manual Loop

To dynamically grow the queue and retry failed chunks, use a manual loop like this:

```ts
const retryQueue = [...queue]; // copy original queue
let index = 0;

while (index < retryQueue.length) {
  const chunk = retryQueue[index];

  const results = await Promise.allSettled(
    chunk.map(async ({ partNumber, url }) => {
      const start = (partNumber - 1) * CHUNK_SIZE;
      const end = Math.min(start + CHUNK_SIZE, file.size);
      const part = file.slice(start, end);

      await axios.put(url, part, {
        signal,
        headers: {
          'Content-Type': file.type,
        },
      });
    })
  );

  const failed = chunk.filter((_, i) => results[i].status === 'rejected');
  if (failed.length > 0) {
    retryQueue.push(failed); // ✅ this works — loop will process it later
  }

  index++;
}
```

---

### 🧠 Why This Works

- `while` loop checks `retryQueue.length` dynamically
- Each time you push a failed chunk, it gets picked up in the next iteration
- You avoid the limitations of `reduce`, which is static and not designed for dynamic queues

---

Let me know if you want to add retry limits, exponential backoff, or progress tracking — I can help you build a resilient and user-friendly uploader.