To parallelize your chunk uploads while still handling retries, youâ€™ll need to:

1. Upload each chunk in parallel (not sequentially).
2. Collect failed chunks.
3. Retry failed chunks in a new round.
4. Repeat until all chunks succeed or you hit a retry limit.

Hereâ€™s how to do that:

---

### âœ… Parallel Chunk Upload with Retry

```ts
async function uploadChunksInParallelWithRetry(
  queue: Array<Array<{ partNumber: number; url: string }>>,
  file: File,
  CHUNK_SIZE: number,
  signal: AbortSignal,
  maxRetries = 3
) {
  let retryQueue = [...queue];
  let attempt = 0;

  while (retryQueue.length > 0 && attempt < maxRetries) {
    const currentQueue = [...retryQueue];
    retryQueue = []; // reset for this round

    const uploadPromises = currentQueue.map(async (chunk) => {
      const results = await Promise.allSettled(
        chunk.map(async ({ partNumber, url }) => {
          const start = (partNumber - 1) * CHUNK_SIZE;
          const end = Math.min(start + CHUNK_SIZE, file.size);
          const part = file.slice(start, end);

          await axios.put(url, part, {
            signal,
            headers: {
              'Content-Type': file.type,
            },
          });
        })
      );

      const failed = chunk.filter((_, i) => results[i].status === 'rejected');
      if (failed.length > 0) {
        retryQueue.push(failed); // retry failed chunk in next round
      }
    });

    await Promise.all(uploadPromises); // run all chunks in parallel
    attempt++;
  }

  if (retryQueue.length > 0) {
    console.error(`Upload failed after ${maxRetries} retries for ${retryQueue.length} chunks`);
  }
}
```

---

### ðŸ§  What This Does

- Uploads all chunks in parallel using `Promise.all`.
- Tracks failed chunks and retries them in the next round.
- Limits retries to `maxRetries` rounds.
- Avoids sequential `await` in loops, so itâ€™s fast and ESLint-friendly.

---

Let me know if you want to add progress tracking, exponential backoff between retries, or a UI-friendly status system.