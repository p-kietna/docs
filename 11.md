Not quite â€” the code you've written **wonâ€™t retry the failed chunks** as intended. Here's why:

---

### âŒ Why It Doesnâ€™t Work

```ts
let queue = [...chunks];

await queue.reduce(async (prevPromise, _, i) => {
  await prevPromise;

  // ...upload logic...

  if (failed.length > 0) {
    queue.push(...failed); // âŒ This modifies queue, but reduce won't re-run
  }
}, Promise.resolve());
```

- `reduce` runs **once per item in the original `queue`**.
- Even if you `push` new items into `queue`, `reduce` wonâ€™t reprocess them.
- So any `failed` chunks added to `queue` are **never retried**.

---

### âœ… How to Fix It: Use a Manual Loop

To retry failed chunks properly, use a `for...of` loop or a manual index loop:

```ts
let queue = [...chunks];
let i = 0;

while (i < queue.length) {
  const chunk = queue[i];
  const results = await Promise.allSettled(
    chunk.map(async ({ partNumber, url }) => {
      const start = (partNumber - 1) * CHUNK_SIZE;
      const end = Math.min(start + CHUNK_SIZE, file.size);
      const part = file.slice(start, end);

      await axios.put(url, part, {
        signal,
        headers: {
          'Content-Type': file.type,
        },
      });
    })
  );

  const failed = chunk.filter((_, idx) => results[idx].status === 'rejected');

  if (failed.length > 0) {
    queue.push(failed); // âœ… This works â€” loop will process it later
  }

  i++;
}
```

---

### ğŸ§  Summary

| Behavior                      | `reduce` | `while` / `for...of` |
|------------------------------|----------|-----------------------|
| Can retry failed chunks      | âŒ        | âœ…                    |
| Can dynamically grow queue   | âŒ        | âœ…                    |
| Best for sequential + retry  | âŒ        | âœ…                    |

---

Let me know if you want to add retry limits or exponential backoff â€” I can help you make this uploader bulletproof.