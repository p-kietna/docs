Yes â€” you can absolutely make `setProgress` more performant, especially if you're updating it frequently during a large file upload. Here are several strategies to optimize it:

---

### âš¡ 1. **Throttle or Debounce Updates**
Instead of calling `setProgress` on every part, only update it every few milliseconds or percentage points.

#### Example: Throttle by percentage change
```tsx
const lastProgressRef = useRef(0);

const updateProgress = (count: number, partCount: number) => {
  const percent = Math.round((count / partCount) * 100);
  if (percent !== lastProgressRef.current) {
    lastProgressRef.current = percent;
    setProgress(percent);
  }
};
```

This avoids redundant re-renders when the percentage hasnâ€™t changed.

---

### ðŸ§  2. **Batch Updates with `requestAnimationFrame`**
If you're uploading many parts quickly, use `requestAnimationFrame` to batch UI updates:

```tsx
const progressRef = useRef(0);

const updateProgress = (count: number, partCount: number) => {
  progressRef.current = Math.round((count / partCount) * 100);
  requestAnimationFrame(() => {
    setProgress(progressRef.current);
  });
};
```

This ensures updates are synced with the browserâ€™s rendering cycle.

---

### ðŸ§® 3. **Use `useRef` for Internal Tracking**
Track `count` with `useRef` to avoid unnecessary state updates:

```tsx
const countRef = useRef(0);

const onPartUploaded = () => {
  countRef.current += 1;
  updateProgress(countRef.current, partCount);
};
```

This keeps your logic clean and avoids triggering re-renders for internal counters.

---

### ðŸ§ª 4. **Update Only at Milestones**
If youâ€™re uploading hundreds of parts, consider updating progress only at key milestones:

```tsx
if (count % 10 === 0 || count === partCount) {
  setProgress(Math.round((count / partCount) * 100));
}
```

This reduces the number of updates dramatically while still giving meaningful feedback.

---

Let me know if you want to animate the progress bar, show estimated time remaining, or add pause/resume support â€” Mantineâ€™s components make it easy to build a slick experience.