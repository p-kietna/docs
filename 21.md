Thanks for clarifying â€” you're describing a **streamed interleaved upload**, where:

- You start uploading a chunk of 10 parts.
- As soon as **any individual part** finishes (e.g. part 3), you want to **immediately begin** uploading the next part from the next chunk (e.g. part 1 of chunk 2).
- This creates a **rolling pipeline** of uploads, not waiting for the entire chunk to finish.

Your current `for await (const chunk of queue)` structure waits for the **entire chunk** to finish before moving on â€” so itâ€™s **chunk-blocked**, not part-streamed.

---

### âœ… What You Need Instead: A Global Part Queue + Concurrency Control

To achieve your goal, you should:

1. Flatten all chunks into a single part queue.
2. Use a **worker pool** to upload parts concurrently.
3. As soon as one part finishes, the next part is pulled and uploaded.

---

### ðŸ§© Code Sketch: Rolling Part-Based Upload

```ts
async function uploadPartsStreamed(
  chunks: Array<Array<{ partNumber: number; url: string }>>,
  file: File,
  CHUNK_SIZE: number,
  signal: AbortSignal,
  maxConcurrent = 5
) {
  const partQueue = chunks.flat(); // flatten all parts
  const failedParts: typeof partQueue = [];
  let active = 0;

  return new Promise<void>((resolve) => {
    const next = async () => {
      if (partQueue.length === 0 && active === 0) {
        return resolve(); // all done
      }

      while (active < maxConcurrent && partQueue.length > 0) {
        const part = partQueue.shift();
        if (!part) continue;

        active++;

        const { partNumber, url } = part;
        const start = (partNumber - 1) * CHUNK_SIZE;
        const end = Math.min(start + CHUNK_SIZE, file.size);
        const chunk = file.slice(start, end);

        axios.put(url, chunk, {
          signal,
          headers: {
            'Content-Type': file.type,
          },
        })
          .catch(() => {
            failedParts.push(part); // collect failed part
          })
          .finally(() => {
            active--;
            next(); // trigger next part immediately
          });
      }
    };

    next(); // kick off initial uploads
  });
}
```

---

### ðŸ§  Why This Works

- Uploads are **part-based**, not chunk-blocked.
- As soon as one part finishes, the next is pulled â€” even if itâ€™s from a different chunk.
- You get **continuous flow** and better bandwidth utilization.

---

Would you like to add retry limits, exponential backoff, or progress tracking to this system? I can help you build a truly resilient uploader.