You're absolutely right to be cautious — and you're touching on a subtle but important point in asynchronous control flow.

In your current code, you're using `axios.put(...)` **without `await`**, inside a `while` loop. That’s intentional in this pattern — but let’s clarify what’s happening and how to fix it if needed.

---

### 🔍 Why `await axios.put(...)` Doesn’t Work Directly in `while`

If you try to use `await` directly inside the `while` loop like this:

```ts
while (active < maxConcurrent && partQueue.length > 0) {
  const part = partQueue.shift();
  active++;

  await axios.put(...); // ❌ This blocks the loop
  active--;
}
```

It will **block the loop**, meaning only one upload happens at a time — defeating the purpose of `maxConcurrent`.

---

### ✅ Correct Pattern: Fire-and-forget with `.finally(next)`

Your current approach is correct for **rolling concurrency**:

```ts
axios.put(...)
  .catch(...)
  .finally(() => {
    active--;
    next(); // trigger next part
  });
```

This lets uploads run **in parallel**, and each one triggers the next when it finishes.

---

### 🧠 Want to Use `await` Safely?

If you prefer using `await`, you need to **wrap each upload in a separate async function** and launch it without blocking the loop:

```ts
const uploadPart = async (part) => {
  const { partNumber, url } = part;
  const start = (partNumber - 1) * CHUNK_SIZE;
  const end = Math.min(start + CHUNK_SIZE, file.size);
  const chunk = file.slice(start, end);

  try {
    await axios.put(url, chunk, {
      signal,
      headers: {
        'Content-Type': file.type,
      },
    });
  } catch {
    failedParts.push(part);
  } finally {
    active--;
    next();
  }
};

while (active < maxConcurrent && partQueue.length > 0) {
  const part = partQueue.shift();
  active++;
  uploadPart(part); // ✅ fire-and-forget
}
```

This preserves concurrency **and** uses `await` inside a safe async context.

---

Let me know if you want to add retry limits, exponential backoff, or a progress bar — this pattern is perfect for building a high-performance uploader.