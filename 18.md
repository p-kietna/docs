Ah, you're asking about the **trigger point** — the exact moment when the next chunk should be pushed or started after the previous one succeeds. This depends on the upload strategy you're using. Let’s break it down:

---

### 🎯 Trigger Point: When to Push the Next Chunk

If you're uploading chunks **sequentially**, the next chunk should be pushed **immediately after the previous chunk finishes successfully**. That means:

```ts
await uploadChunk(chunk); // ✅ success
queue.push(nextChunk);    // 🔁 trigger next
```

But in a **parallel or dynamic queue system**, the trigger point is inside the **worker loop**:

```ts
while (queue.length > 0) {
  const chunk = queue.shift();
  await uploadChunk(chunk); // ✅ success
  // Automatically continues to next chunk
}
```

Here, the act of finishing one chunk **automatically triggers** the next because the loop continues.

---

### 🧠 Key Insight

You don’t need to manually “push” the next chunk if your loop or worker is already pulling from a queue. The **completion of one chunk is the signal** to dequeue and start the next.

If you're using a **concurrent pool**, each worker does this:

```ts
async function worker() {
  while (queue.length > 0) {
    const chunk = queue.shift();
    await uploadChunk(chunk); // ✅ success
    // Loop continues, next chunk is pulled
  }
}
```

So the **trigger point is the end of `await uploadChunk()`** — that’s when the next chunk is automatically fetched.

---

Let me know if you want to throttle concurrency, stream chunks based on file size, or retry only failed parts — I can help you fine-tune the flow.