Great observation â€” the reason `useRef` shows up in many of the performance suggestions is because it's a **powerful tool for tracking mutable values without triggering re-renders**. Here's why it's so useful in upload progress scenarios:

---

### ðŸ§  Why `useRef` Is Common in Performance Patterns

#### 1. **Avoids Re-renders**
- `useState` triggers a re-render every time it updates.
- `useRef` does **not** â€” it silently holds values across renders.
- This is perfect for things like counters, timestamps, or internal flags that donâ€™t need to update the UI directly.

#### 2. **Efficient for High-Frequency Updates**
- Uploading hundreds of parts? Updating `useState` each time can cause **too many re-renders**, slowing down your app.
- `useRef` lets you track progress internally and only update the UI when necessary (e.g. every 5%, every 100ms, etc.).

#### 3. **Works Well with Throttling**
- You can store the last known progress in a `ref`, and only call `setProgress` when it changes meaningfully.
- This avoids redundant updates like going from 21% â†’ 22% â†’ 23% in rapid succession.

#### 4. **Safe Across Async Boundaries**
- `useRef` persists even inside async functions, promises, or event handlers.
- You can increment a `ref` inside an upload loop without worrying about stale closures.

---

### ðŸ”§ Example: Combining `useRef` + `useState` for Smart Progress

```tsx
const progressRef = useRef(0);
const [progress, setProgress] = useState(0);

const updateProgress = (count: number, partCount: number) => {
  const percent = Math.round((count / partCount) * 100);
  if (percent !== progressRef.current) {
    progressRef.current = percent;
    setProgress(percent); // only when needed
  }
};
```

This gives you the **best of both worlds**: efficient internal tracking and responsive UI updates.

---

Let me know if you want to add a progress bar with animation, estimated time remaining, or pause/resume support â€” I can help you build a slick and resilient uploader.