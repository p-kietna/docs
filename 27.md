Great question â€” and the short answer is: **no, `useRef` alone wonâ€™t trigger a re-render**, so your `<Progress />` component **wonâ€™t update visually** if you're only using `useRef` to track progress.

---

### ğŸ§  Why `useRef` Doesnâ€™t Work for UI Updates

- `useRef` is perfect for **mutable values** that persist across renders.
- But it **doesnâ€™t cause a re-render** when its value changes.
- React components like Mantineâ€™s `<Progress />` rely on **state updates** (`useState`) to re-render with new values.

---

### âœ… What You Should Do

If you want to track progress efficiently and still update the UI:

#### Option 1: Stick with `useState` (recommended for UI-bound values)

```tsx
const [progress, setProgress] = useState(0);

count += 1;
setProgress(Math.round((count / partCount) * 100));
```

This ensures `<Progress value={progress} />` updates correctly.

#### Option 2: Use `useRef` for internal tracking + `useState` for UI

```tsx
const progressRef = useRef(0);
const [progress, setProgress] = useState(0);

progressRef.current += 1;
const percent = Math.round((progressRef.current / partCount) * 100);
setProgress(percent);
```

This lets you avoid unnecessary re-renders for internal logic, while still updating the UI when needed.

---

### ğŸ” Bonus Tip: Throttle UI Updates

If youâ€™re updating progress very frequently (e.g. hundreds of parts), consider throttling `setProgress` to avoid performance issues:

```tsx
if (percent !== progress) {
  setProgress(percent);
}
```

---

Let me know if you want to add a spinner, label, or animated transitions to your progress bar â€” Mantine makes that super slick.