You're absolutely right â€” TypeScript (and JavaScript) doesn't allow `await` inside synchronous loops like `forEach`, `map`, or `reduce` in a way that guarantees sequential execution. But it **does allow `await` inside `for...of` loops**, which are asynchronous-friendly and fully supported.

---

### âœ… Best Practice: Use `for...of` with `await`

```ts
for (const chunk of chunks) {
  const results = await Promise.allSettled(
    chunk.map(async ({ partNumber, url }) => {
      const start = (partNumber - 1) * CHUNK_SIZE;
      const end = Math.min(start + CHUNK_SIZE, file.size);
      const part = file.slice(start, end);

      await axios.put(url, part, {
        signal,
        headers: {
          'Content-Type': file.type,
        },
      });
    })
  );

  const failed = chunk.filter((_, i) => results[i].status === 'rejected');
  if (failed.length > 0) {
    chunks.push(failed); // retry logic
  }
}
```

---

### ðŸ§  Why `for...of` Works

- Itâ€™s **asynchronous-safe**: each iteration waits for the previous one to finish.
- It avoids the pitfalls of `reduce` or `map`, which donâ€™t handle `await` sequentially.
- Itâ€™s clean, readable, and works perfectly with retry logic.

---

If you want to limit retries or add exponential backoff, I can help you layer that in. Want to make this uploader bulletproof with progress tracking next?